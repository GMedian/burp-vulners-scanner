package burp.models;

import com.google.common.collect.Lists;
import org.json.JSONArray;
import org.json.JSONObject;

import java.util.List;

public class PathVulnerability extends Vulnerability {

    private String parameter="";
    private String url="";
    private String position="";
    // description is in Base class

    private List<String> cwe=null;
    private boolean isOriginal=false;
    /*
    Since response may contain other urls, lets store them here and show as hints
    Because we cant technically claim that these URLs actually exist on the server
    We shouldn't add false positives
    */
    private List<PathVulnerability> potentials=Lists.newArrayList();

    private PathVulnerability(){}

    private PathVulnerability(double metricsScore, String cveId, List<String[]> exploits){
        super();

        this.setCvssScore(metricsScore);
        this.setId(cveId);
        this.setExploits(exploits);

        //set it by default since it doesn't come from server
        this.setType("cve");
    }


    public static PathVulnerability fromWebVulns(String originalPath, JSONObject webVulnBulletin) {
        PathVulnerability vulnerability=null;
        List<PathVulnerability> potentials = Lists.newArrayList();
        String cveId = webVulnBulletin.optString("id");
        List<String[]> exploits = Lists.newArrayList();

        // We don't really need to specify the reference type since all IDs are unique, so just hardcode "exploit"
        webVulnBulletin.optJSONArray("exploits", new JSONArray())
                .forEach(e -> exploits.add(new String[]{"exploit", (String)e}));


        // this value actually only impacts the colour of the Issue, so just take the highest available metric, which
        // might in fact not be cvss
        double metricsScore = getHighestMetric(webVulnBulletin.optJSONObject("metrics", new JSONObject()));


        for (Object vuln : webVulnBulletin.getJSONObject("webApplicability").getJSONArray("vulnerabilities")) {
            JSONObject v = (JSONObject) vuln;

            // Set only the first entry as the main vuln not to overwrite the exusting one
            if(v.getString("url").replaceFirst("^/?(.*)/?$","\1")
                    .equals(
                            originalPath.replaceFirst("^/?(.*)/?$","\1")
                    ) && vulnerability == null) {
                vulnerability = fromSingleWebVuln(v, cveId, metricsScore, exploits);
                vulnerability.setOriginal(true);
            }
            else {
                potentials.add(PathVulnerability.fromSingleWebVuln(v, cveId, metricsScore, exploits));
            }
        }

        if(vulnerability == null){
            vulnerability = new PathVulnerability(metricsScore, cveId, exploits);
        }

        potentials.forEach(vulnerability::addPotential);

        return vulnerability;
    }

    private static PathVulnerability fromSingleWebVuln(JSONObject singleUrlBulletin, String cveId, double metricsScore, List<String[]> exploits){
        PathVulnerability vulnerability = new PathVulnerability(metricsScore, cveId, exploits);

        vulnerability.setParameter(singleUrlBulletin.optString("parameter",""));
        vulnerability.setUrl(singleUrlBulletin.optString("url",""));
        vulnerability.setPosition(singleUrlBulletin.optString("position",""));
        vulnerability.setDescription(singleUrlBulletin.optString("description",""));

        singleUrlBulletin.optJSONArray("cwe").forEach(cwe -> {
            vulnerability.addCWE((String) cwe);
        });

        return vulnerability;
    }

    private static double getHighestMetric(JSONObject metrics){
        double highest=0;
        double current;
        JSONObject singleMetric;

        // nvd for expample
        for(String metricSource : metrics.keySet()){
            // cvss2 for example
            for(String metricSourceType: metrics.getJSONObject(metricSource).keySet()) {
                singleMetric = metrics.getJSONObject(metricSource).optJSONObject(metricSourceType);
                if(singleMetric == null) {
                    throw new RuntimeException("Something went wrong with finding metrics");
                }
                current = singleMetric.optDouble("baseScore",0);
                if(current > highest){
                    highest = current;
                }
            }
        }

        return highest;
    }


    private void addCWE(String cwe){
        if(this.cwe == null)
            this.cwe = Lists.newArrayList();
        this.cwe.add(cwe);
    }

    private void addPotential(PathVulnerability vuln){
        if(this.potentials == null)
            this.potentials = Lists.newArrayList();
        this.potentials.add(vuln);
    }

    public String getParameter() {
        return parameter;
    }

    public void setParameter(String parameter) {
        this.parameter = parameter;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    public boolean isOriginal() {
        return isOriginal;
    }

    private void setOriginal(boolean original) {
        isOriginal = original;
    }

    public List<PathVulnerability> getPotentials() {
        return potentials;
    }
}
